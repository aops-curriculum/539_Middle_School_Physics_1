<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=600">
<title>Haibao Mirror Lower – Ray Tracing</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    width: 600px;
    font-family: Arial, sans-serif;
    background: #fff;
    overflow-x: hidden;
  }
  canvas {
    display: block;
    cursor: crosshair;
    width: 600px;
    height: 400px;
  }
  #controls {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 6px 12px;
    background: #f0f0f0;
    border-bottom: 1px solid #ccc;
    height: 36px;
    width: 600px;
  }
  #instruction {
    font-size: 14px;
    color: #333;
    flex: 1;
  }
  #resetBtn {
    padding: 4px 16px;
    font-size: 14px;
    cursor: pointer;
    border: 1px solid #999;
    border-radius: 4px;
    background: #fff;
  }
  #resetBtn:hover { background: #e0e0e0; }
  #info {
    padding: 6px 12px;
    font-size: 15px;
    font-family: monospace;
    line-height: 1.6;
    color: #333;
    min-height: 10px;
    background: #f9f9f9;
    border-top: 1px solid #ccc;
    white-space: pre;
    width: 600px;
  }
  #warning {
    padding: 8px 12px;
    font-size: 13px;
    color: #b00;
    background: #fff3f3;
    border-top: 1px solid #fcc;
    display: none;
    width: 600px;
  }
</style>
</head>
<body>
<div id="controls">
  <span id="instruction">Click the point where your ray ends (on Haibao).</span>
  <button id="resetBtn">Reset</button>
</div>
<canvas id="canvas" width="1200" height="800"></canvas>
<div id="info"></div>
<div id="warning"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const instructionEl = document.getElementById('instruction');
const infoEl = document.getElementById('info');
const warningEl = document.getElementById('warning');
const resetBtn = document.getElementById('resetBtn');

// HiDPI: canvas is 1200x800 but displayed at 600x400 via CSS
const DPR = 2;
ctx.scale(DPR, DPR);

// --- Style constants ---
const BROWN = '#8B4513';
const LABEL_FONT = 'bold 17px Arial';
const RED = '#e00';
const BLUE = '#00c';

// --- Coordinate system ---
const SCALE = 6; // pixels per cm

// Physical measurements in cm
const STUFFIE_HEIGHT = 56;
const MIRROR_HEIGHT = 17;
const MIRROR_BOTTOM = 28;
const MIRROR_TOP = 45;
const DISTANCE = 50;

// Layout
const GROUND_Y_PX = 380;
const STUFFIE_TOP_Y = GROUND_Y_PX - STUFFIE_HEIGHT * SCALE;

const IMG_ASPECT = 0.528;
let imgAspect = IMG_ASPECT;

const ARROW_LEFT_X = 22;
const STUFFIE_CENTER_X = 138;

const MIRROR_X = STUFFIE_CENTER_X + DISTANCE * SCALE;
const ARROW_RIGHT_X = MIRROR_X + 25;

function cmToY(cm) {
  return GROUND_Y_PX - cm * SCALE;
}

function yToCm(y) {
  return (GROUND_Y_PX - y) / SCALE;
}

// --- Image loading ---
const stuffieImg = new Image();
let imgLoaded = false;
let transparentCanvas = null;

stuffieImg.onload = () => {
  imgLoaded = true;
  imgAspect = stuffieImg.width / stuffieImg.height;
  makeTransparent();
  drawScene();
};
stuffieImg.onerror = () => {
  if (stuffieImg.src.endsWith('.jpg')) {
    stuffieImg.src = 'haibao.png';
  } else if (stuffieImg.src.endsWith('.png')) {
    stuffieImg.src = 'haibao.jpg';
  } else {
    imgLoaded = false;
    drawScene();
  }
};
stuffieImg.src = 'haibao.jpg';

function makeTransparent() {
  const tc = document.createElement('canvas');
  tc.width = stuffieImg.width;
  tc.height = stuffieImg.height;
  const tctx = tc.getContext('2d');
  tctx.drawImage(stuffieImg, 0, 0);
  const imageData = tctx.getImageData(0, 0, tc.width, tc.height);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    if (d[i] > 230 && d[i+1] > 230 && d[i+2] > 230) {
      d[i+3] = 0;
    }
  }
  tctx.putImageData(imageData, 0, 0);
  transparentCanvas = tc;
}

// --- State ---
// firstClick = end of ray (on Haibao), secondClick = beginning of ray (on mirror)
let state = 'waiting_first';
let firstClick = null;
let secondClick = null;
let mousePos = null;

// --- Drawing ---
function drawScene() {
  ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);

  // Ground line
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(10, GROUND_Y_PX);
  ctx.lineTo(530, GROUND_Y_PX);
  ctx.stroke();

  drawStuffie();
  drawMirror();
  drawDimensionArrows();

  // Preview ray while waiting for second click
  if (state === 'waiting_second' && firstClick && mousePos) {
    drawArrow(mousePos.x, mousePos.y, firstClick.x, firstClick.y, RED, 2.5);
  }

  // Once done: draw the full picture
  if (state === 'done' && firstClick && secondClick) {
    // Dashed horizontal line at the mirror contact point height
    drawDashedLine();

    // 1) Mirror-to-Haibao ray (red, goes UP to eye — label above dashed line)
    drawArrow(secondClick.x, secondClick.y, firstClick.x, firstClick.y, RED, 2.5);
    drawAngleArc(firstClick.x, firstClick.y, secondClick.x, secondClick.y, RED, false);

    // 2) Reflected ray: Haibao-to-mirror (blue, goes DOWN — label below dashed line)
    // Mirror the eye point across the dashed line (secondClick.y)
    const reflectedY = 2 * secondClick.y - firstClick.y;
    drawArrow(firstClick.x, reflectedY, secondClick.x, secondClick.y, BLUE, 2.5);
    drawAngleArc(firstClick.x, reflectedY, secondClick.x, secondClick.y, BLUE, true);

    // Height arrow for where the incident ray starts on Haibao
    drawHeightArrow(reflectedY);
  }
}

function drawStuffie() {
  const topY = STUFFIE_TOP_Y;
  const heightPx = GROUND_Y_PX - topY;
  if (transparentCanvas) {
    const drawWidth = heightPx * imgAspect;
    const drawX = STUFFIE_CENTER_X - drawWidth / 2;
    ctx.drawImage(transparentCanvas, drawX, topY, drawWidth, heightPx);
  } else {
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    const w = heightPx * IMG_ASPECT;
    ctx.strokeRect(STUFFIE_CENTER_X - w/2, topY, w, heightPx);
    ctx.setLineDash([]);
    ctx.fillStyle = '#999';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Haibao', STUFFIE_CENTER_X, topY + heightPx / 2);
  }
}

function drawMirror() {
  const mirrorTopY = cmToY(MIRROR_TOP);
  const mirrorBottomY = cmToY(MIRROR_BOTTOM);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(MIRROR_X, mirrorTopY);
  ctx.lineTo(MIRROR_X, mirrorBottomY);
  ctx.stroke();
}

function drawDoubleArrow(x, y1, y2, label, color) {
  const headLen = 7;
  const c = color || BROWN;
  ctx.strokeStyle = c;
  ctx.fillStyle = c;
  ctx.lineWidth = 1.5;

  ctx.beginPath();
  ctx.moveTo(x, y1 + headLen);
  ctx.lineTo(x, y2 - headLen);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x, y1);
  ctx.lineTo(x - 4, y1 + headLen);
  ctx.lineTo(x + 4, y1 + headLen);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(x, y2);
  ctx.lineTo(x - 4, y2 - headLen);
  ctx.lineTo(x + 4, y2 - headLen);
  ctx.closePath();
  ctx.fill();

  ctx.save();
  ctx.translate(x, (y1 + y2) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = LABEL_FONT;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const tw = ctx.measureText(label).width;
  ctx.fillStyle = '#fff';
  ctx.fillRect(-tw/2 - 3, -10, tw + 6, 20);
  ctx.fillStyle = c;
  ctx.fillText(label, 0, 0);
  ctx.restore();
}

function drawDimensionArrows() {
  const stuffieTopY = cmToY(STUFFIE_HEIGHT);
  drawDoubleArrow(ARROW_LEFT_X, stuffieTopY, GROUND_Y_PX, '56 cm');

  ctx.strokeStyle = BROWN;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(ARROW_LEFT_X - 5, stuffieTopY);
  ctx.lineTo(ARROW_LEFT_X + 5, stuffieTopY);
  ctx.moveTo(ARROW_LEFT_X - 5, GROUND_Y_PX);
  ctx.lineTo(ARROW_LEFT_X + 5, GROUND_Y_PX);
  ctx.stroke();

  const mirrorTopY = cmToY(MIRROR_TOP);
  const mirrorBottomY = cmToY(MIRROR_BOTTOM);
  drawDoubleArrow(ARROW_RIGHT_X, mirrorTopY, mirrorBottomY, '17 cm');

  ctx.beginPath();
  ctx.moveTo(ARROW_RIGHT_X - 5, mirrorTopY);
  ctx.lineTo(ARROW_RIGHT_X + 5, mirrorTopY);
  ctx.moveTo(ARROW_RIGHT_X - 5, mirrorBottomY);
  ctx.lineTo(ARROW_RIGHT_X + 5, mirrorBottomY);
  ctx.stroke();
}

function drawArrow(fromX, fromY, toX, toY, color, width) {
  const headLen = 12;
  const angle = Math.atan2(toY - fromY, toX - fromX);

  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = width;

  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(toX - headLen * Math.cos(angle - 0.35), toY - headLen * Math.sin(angle - 0.35));
  ctx.lineTo(toX - headLen * Math.cos(angle + 0.35), toY - headLen * Math.sin(angle + 0.35));
  ctx.closePath();
  ctx.fill();
}

function drawDashedLine() {
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(STUFFIE_CENTER_X, secondClick.y);
  ctx.lineTo(MIRROR_X, secondClick.y);
  ctx.stroke();
  ctx.setLineDash([]);
}

// Generic angle arc between a ray endpoint and the mirror contact point.
// rayEndX, rayEndY: the far end of the ray (on Haibao side).
// mirrorPtX, mirrorPtY: the point on the mirror where the ray meets.
// color: arc and label color.
// labelBelow: if true, place label below the dashed line; if false, above.
function drawAngleArc(rayEndX, rayEndY, mirrorPtX, mirrorPtY, color, labelBelow) {
  const dx = rayEndX - mirrorPtX;
  const dy = rayEndY - mirrorPtY;
  const rayAngle = Math.atan2(dy, dx);
  const angleDeg = Math.abs(Math.atan2(Math.abs(dy), Math.abs(dx))) * 180 / Math.PI;

  const arcRadius = 22;
  const horizAngle = dx < 0 ? Math.PI : 0;

  let diff = rayAngle - horizAngle;
  while (diff > Math.PI) diff -= 2 * Math.PI;
  while (diff <= -Math.PI) diff += 2 * Math.PI;
  const useAntiClockwise = diff < 0;

  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(mirrorPtX, mirrorPtY, arcRadius, horizAngle, rayAngle, useAntiClockwise);
  ctx.stroke();

  // Label placement
  const labelX = mirrorPtX - arcRadius - 24;
  const labelY = labelBelow ? mirrorPtY + 16 : mirrorPtY - 16;

  ctx.font = LABEL_FONT;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const text = angleDeg.toFixed(1) + '\u00B0';
  const tw = ctx.measureText(text).width;
  ctx.fillStyle = '#fff';
  ctx.fillRect(labelX - tw/2 - 3, labelY - 9, tw + 6, 18);
  ctx.fillStyle = color;
  ctx.fillText(text, labelX, labelY);
}

function drawHeightArrow(startY) {
  const heightCm = yToCm(startY);
  const arrowX = MIRROR_X + 75;
  const topY = startY;
  const bottomY = GROUND_Y_PX;

  if (bottomY - topY < 10) return;

  const label = heightCm.toFixed(1) + ' cm';
  const headLen = 7;
  ctx.strokeStyle = BLUE;
  ctx.fillStyle = BLUE;
  ctx.lineWidth = 1.5;

  ctx.beginPath();
  ctx.moveTo(arrowX, topY + headLen);
  ctx.lineTo(arrowX, bottomY - headLen);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(arrowX, topY);
  ctx.lineTo(arrowX - 4, topY + headLen);
  ctx.lineTo(arrowX + 4, topY + headLen);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(arrowX, bottomY);
  ctx.lineTo(arrowX - 4, bottomY - headLen);
  ctx.lineTo(arrowX + 4, bottomY - headLen);
  ctx.closePath();
  ctx.fill();

  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(arrowX - 5, topY);
  ctx.lineTo(arrowX + 5, topY);
  ctx.moveTo(arrowX - 5, bottomY);
  ctx.lineTo(arrowX + 5, bottomY);
  ctx.stroke();

  ctx.save();
  ctx.translate(arrowX, (topY + bottomY) / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = LABEL_FONT;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const tw = ctx.measureText(label).width;
  ctx.fillStyle = '#fff';
  ctx.fillRect(-tw/2 - 3, -10, tw + 6, 20);
  ctx.fillStyle = BLUE;
  ctx.fillText(label, 0, 0);
  ctx.restore();
}

// --- Interaction ---
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mousePos = {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
  if (state === 'waiting_second') {
    drawScene();
  }
});

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  if (state === 'waiting_first') {
    firstClick = { x: clickX, y: clickY };
    state = 'waiting_second';
    instructionEl.textContent = 'Click the point where your ray begins (on the mirror).';
    drawScene();
  } else if (state === 'waiting_second') {
    secondClick = { x: clickX, y: clickY };
    state = 'done';
    instructionEl.textContent = '';

    checkBackward();
    showInfo();
    drawScene();
  }
});

function checkBackward() {
  const tolerance = 10 * SCALE;
  const firstNearMirror = Math.abs(firstClick.x - MIRROR_X) < tolerance;
  const secondNearStuffie = Math.abs(secondClick.x - STUFFIE_CENTER_X) < tolerance;
  if (firstNearMirror && secondNearStuffie) {
    warningEl.style.display = 'block';
    warningEl.textContent = "It looks like you drew a ray from Haibao to the mirror. Make sure you draw a ray that enters Haibao\u2019s eye from the mirror. Note that on this simulation, you choose the END of the ray first.";
  }
}

function showInfo() {
  // Reflection angle
  const dx = firstClick.x - secondClick.x;
  const dy = firstClick.y - secondClick.y;
  const reflAngleDeg = Math.abs(Math.atan2(Math.abs(dy), Math.abs(dx))) * 180 / Math.PI;

  // Incident ray start height
  const reflectedY = 2 * secondClick.y - firstClick.y;
  const incidentHeightCm = yToCm(reflectedY);

  // Normal height (where ray hits mirror)
  const normalHeightCm = yToCm(secondClick.y);

  const angleStr = reflAngleDeg.toFixed(1);
  const incHeightStr = incidentHeightCm.toFixed(1);
  const normalStr = normalHeightCm.toFixed(1);

  infoEl.textContent =
    `normal height       = ${normalStr} cm\n` +
    `angle of reflection = ${angleStr}\u00B0\n` +
    `angle of incidence  = ${angleStr}\u00B0\n` +
    `incident height     = ${incHeightStr} cm`;
}

resetBtn.addEventListener('click', reset);

function reset() {
  state = 'waiting_first';
  firstClick = null;
  secondClick = null;
  mousePos = null;
  instructionEl.textContent = 'Click the point where your ray ends (on Haibao).';
  infoEl.textContent = '';
  warningEl.style.display = 'none';
  drawScene();
}

drawScene();
</script>
</body>
</html>
