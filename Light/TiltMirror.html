<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilt Mirror</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            min-height: 100vh;
            max-width: 600px;
            margin: 0 auto;
            user-select: none;
        }
        #instructions {
            margin: 12px 0 8px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        canvas {
            border: 1px solid #999;
            border-radius: 6px;
            background: #fff;
        }
        #controls {
            display: flex;
            gap: 18px;
            margin: 10px 0;
            font-size: 13px;
            color: #444;
        }
        #controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <p id="instructions">Drag the mirror to tilt it. Slide the coin or move the eye.</p>
    <canvas id="canvas" width="600" height="700"></canvas>
    <div id="controls">
        <label><input type="checkbox" id="cbRays" checked> Rays</label>
        <label><input type="checkbox" id="cbImage" checked> Image</label>
        <label><input type="checkbox" id="cbProjections" checked> Projections</label>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Layout
        const tableY = 440;

        // Coin (lying flat on table)
        const coinHalfW = 18;
        const coinThickness = 6;
        let coinX = 120;

        // Eye
        const eyeRadius = 18;
        let eyeX = 250;
        let eyeY = 65;

        // Mirror
        const mirrorBaseX = 280;
        const mirrorBaseY = tableY;
        const mirrorLength = 160;
        let mirrorAngle = 0;
        const maxTilt = 40 * Math.PI / 180;

        // Drag state
        let dragTarget = null; // 'mirror', 'coin', 'eye'

        // Checkbox state
        let showRays = true;
        let showImage = true;
        let showProjections = true;

        // Source point: center of the coin top surface
        function getCoinSource() {
            return { x: coinX, y: tableY - coinThickness };
        }

        function getMirrorTop() {
            return {
                x: mirrorBaseX + mirrorLength * Math.sin(mirrorAngle),
                y: mirrorBaseY - mirrorLength * Math.cos(mirrorAngle)
            };
        }

        function reflectPoint(P, base, top) {
            const dx = top.x - base.x, dy = top.y - base.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const ux = dx / len, uy = dy / len;
            const vx = P.x - base.x, vy = P.y - base.y;
            const dot = vx * ux + vy * uy;
            const perpX = vx - dot * ux, perpY = vy - dot * uy;
            return { x: P.x - 2 * perpX, y: P.y - 2 * perpY };
        }

        function lineIntersect(p1, p2, p3, p4) {
            const d1x = p2.x - p1.x, d1y = p2.y - p1.y;
            const d2x = p4.x - p3.x, d2y = p4.y - p3.y;
            const denom = d1x * d2y - d1y * d2x;
            if (Math.abs(denom) < 1e-10) return null;
            const t = ((p3.x - p1.x) * d2y - (p3.y - p1.y) * d2x) / denom;
            const u = ((p3.x - p1.x) * d1y - (p3.y - p1.y) * d1x) / denom;
            return { t, u, x: p1.x + t * d1x, y: p1.y + t * d1y };
        }

        function computeReflection(source, eye, mBase, mTop) {
            const vi = reflectPoint(source, mBase, mTop);
            const hit = lineIntersect(eye, vi, mBase, mTop);
            if (!hit || hit.u < 0.01 || hit.u > 0.99) return null;
            return { x: hit.x, y: hit.y, virtualImage: vi };
        }

        function drawRayArrow(x1, y1, x2, y2, color, lw) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lw;
            ctx.stroke();

            const t = 0.6;
            const tipX = x1 + t * (x2 - x1);
            const tipY = y1 + t * (y2 - y1);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headLen = 13;

            ctx.beginPath();
            ctx.moveTo(tipX, tipY);
            ctx.lineTo(tipX - headLen * Math.cos(angle - Math.PI / 6),
                       tipY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(tipX - headLen * Math.cos(angle + Math.PI / 6),
                       tipY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawTable() {
            ctx.beginPath();
            ctx.moveTo(0, tableY);
            ctx.lineTo(W, tableY);
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawCoin() {
            const x = coinX - coinHalfW;
            const y = tableY - coinThickness;
            const w = coinHalfW * 2;
            const h = coinThickness;

            ctx.fillStyle = '#CD7F32';
            ctx.strokeStyle = '#8B5A2B';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 2);
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = '#666';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('coin', coinX, y - 10);
        }

        function drawEye(cx, cy, lookX, lookY) {
            const dx = lookX - cx, dy = lookY - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const offX = dist > 1 ? (dx / dist) * eyeRadius * 0.25 : 0;
            const offY = dist > 1 ? (dy / dist) * eyeRadius * 0.25 : 0;

            ctx.beginPath();
            ctx.ellipse(cx, cy, eyeRadius * 1.5, eyeRadius, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#f0f0f0';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(cx + offX, cy + offY, eyeRadius * 0.55, 0, Math.PI * 2);
            ctx.fillStyle = '#4a7a5a';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(cx + offX, cy + offY, eyeRadius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(cx + offX - 2, cy + offY - 2, eyeRadius * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fill();
        }

        function drawAngleIndicator() {
            // Dashed vertical reference line from mirror base straight up
            ctx.beginPath();
            ctx.setLineDash([6, 4]);
            ctx.moveTo(mirrorBaseX, mirrorBaseY);
            ctx.lineTo(mirrorBaseX, mirrorBaseY - mirrorLength - 15);
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.setLineDash([]);

            const angleDeg = Math.round(Math.abs(mirrorAngle) * 180 / Math.PI);
            if (angleDeg < 1) return;

            // Arc between vertical and mirror
            const arcR = 40;
            const vertAngle = -Math.PI / 2;
            const mirrorDir = -Math.PI / 2 + mirrorAngle;

            ctx.beginPath();
            if (mirrorAngle > 0) {
                ctx.arc(mirrorBaseX, mirrorBaseY, arcR, vertAngle, mirrorDir, false);
            } else {
                ctx.arc(mirrorBaseX, mirrorBaseY, arcR, mirrorDir, vertAngle, false);
            }
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Angle label
            const midA = vertAngle + mirrorAngle / 2;
            const labelR = arcR + 14;
            ctx.fillStyle = '#555';
            ctx.font = '13px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(angleDeg + 'Â°',
                         mirrorBaseX + labelR * Math.cos(midA),
                         mirrorBaseY + labelR * Math.sin(midA));
            ctx.textBaseline = 'alphabetic';
        }

        function drawMirror() {
            const top = getMirrorTop();
            const base = { x: mirrorBaseX, y: mirrorBaseY };

            ctx.beginPath();
            ctx.moveTo(base.x, base.y);
            ctx.lineTo(top.x, top.y);
            ctx.strokeStyle = '#2255aa';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.lineCap = 'butt';

            // Hash marks on the non-reflective side
            const dx = top.x - base.x, dy = top.y - base.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const ux = dx / len, uy = dy / len;

            const n1x = -uy, n1y = ux;
            const n2x = uy, n2y = -ux;
            const midX = (base.x + top.x) / 2, midY = (base.y + top.y) / 2;
            const toCoinX = coinX - midX;
            const toCoinY = (tableY - coinThickness / 2) - midY;
            const dot1 = n1x * toCoinX + n1y * toCoinY;
            const nx = dot1 > 0 ? n2x : n1x;
            const ny = dot1 > 0 ? n2y : n1y;

            ctx.strokeStyle = '#2255aa';
            ctx.lineWidth = 1.5;
            const numMarks = 10;
            for (let i = 1; i < numMarks; i++) {
                const t = i / numMarks;
                const px = base.x + t * dx;
                const py = base.y + t * dy;
                const hx = nx + ux, hy = ny + uy;
                const hScale = 8 / Math.sqrt(hx * hx + hy * hy);
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + hx * hScale, py + hy * hScale);
                ctx.stroke();
            }

            // Draggable handle at top
            ctx.beginPath();
            ctx.arc(top.x, top.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = dragTarget === 'mirror' ? 'rgba(34,85,170,0.5)' : 'rgba(34,85,170,0.25)';
            ctx.fill();
            ctx.strokeStyle = '#2255aa';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#2255aa';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            const labelOffX = nx * 22;
            const labelOffY = ny * 22;
            ctx.save();
            const labelX = midX + labelOffX;
            const labelY = midY + labelOffY;
            const textAngle = Math.atan2(dy, dx);
            ctx.translate(labelX, labelY);
            ctx.rotate(textAngle);
            ctx.fillText('mirror', 0, 4);
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);

            const mBase = { x: mirrorBaseX, y: mirrorBaseY };
            const mTop = getMirrorTop();
            const eye = { x: eyeX, y: eyeY };

            drawTable();
            drawAngleIndicator();

            const source = getCoinSource();
            const rayColor = '#cc6600';
            const refl = computeReflection(source, eye, mBase, mTop);

            // Projection: dashed line from eye through reflection point to virtual image
            if (showProjections && refl) {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.moveTo(eye.x, eye.y);
                ctx.lineTo(refl.virtualImage.x, refl.virtualImage.y);
                ctx.strokeStyle = 'rgba(180, 100, 40, 0.35)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Image of coin (same size as coin, reflected through mirror)
            if (showImage && refl) {
                const viL = reflectPoint({ x: coinX - coinHalfW, y: tableY - coinThickness }, mBase, mTop);
                const viR = reflectPoint({ x: coinX + coinHalfW, y: tableY - coinThickness }, mBase, mTop);
                const viBL = reflectPoint({ x: coinX - coinHalfW, y: tableY }, mBase, mTop);
                const viBR = reflectPoint({ x: coinX + coinHalfW, y: tableY }, mBase, mTop);

                ctx.fillStyle = 'rgba(205, 127, 50, 0.35)';
                ctx.strokeStyle = 'rgba(139, 90, 43, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(viL.x, viL.y);
                ctx.lineTo(viR.x, viR.y);
                ctx.lineTo(viBR.x, viBR.y);
                ctx.lineTo(viBL.x, viBL.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);

                const vmx = (viL.x + viR.x) / 2;
                const vmy = Math.min(viL.y, viR.y);
                ctx.fillStyle = 'rgba(140, 80, 20, 0.6)';
                ctx.font = '13px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('image point', vmx, vmy - 10);
            }

            // Ray
            if (showRays && refl) {
                drawRayArrow(source.x, source.y, refl.x, refl.y, rayColor, 2.5);
                drawRayArrow(refl.x, refl.y, eye.x, eye.y, rayColor, 2.5);
            }

            drawMirror();
            drawCoin();

            const mirrorMidX = (mBase.x + mTop.x) / 2;
            const mirrorMidY = (mBase.y + mTop.y) / 2;
            drawEye(eyeX, eyeY, mirrorMidX, mirrorMidY);

            ctx.fillStyle = '#444';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('eye', eyeX, eyeY - eyeRadius - 8);
        }

        // --- Interaction ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const src = e.touches ? e.touches[0] : e;
            return {
                x: (src.clientX - rect.left) * (W / rect.width),
                y: (src.clientY - rect.top) * (H / rect.height)
            };
        }

        function distToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1, dy = y2 - y1;
            const len2 = dx * dx + dy * dy;
            let t = ((px - x1) * dx + (py - y1) * dy) / len2;
            t = Math.max(0, Math.min(1, t));
            const nx = x1 + t * dx, ny = y1 + t * dy;
            return Math.sqrt((px - nx) ** 2 + (py - ny) ** 2);
        }

        function startDrag(e) {
            const pos = getPos(e);

            // Check eye
            const dEye = Math.sqrt((pos.x - eyeX) ** 2 + (pos.y - eyeY) ** 2);
            if (dEye < 28) { dragTarget = 'eye'; draw(); return; }

            // Check coin
            const coinCY = tableY - coinThickness / 2;
            const dCoin = Math.abs(pos.x - coinX) < coinHalfW + 15 &&
                          Math.abs(pos.y - coinCY) < 25;
            if (dCoin) { dragTarget = 'coin'; draw(); return; }

            // Check mirror
            const top = getMirrorTop();
            const dTop = Math.sqrt((pos.x - top.x) ** 2 + (pos.y - top.y) ** 2);
            const dSeg = distToSegment(pos.x, pos.y, mirrorBaseX, mirrorBaseY, top.x, top.y);
            if (dTop < 35 || dSeg < 20) { dragTarget = 'mirror'; draw(); return; }
        }

        function moveDrag(e) {
            if (!dragTarget) {
                // Update cursor on hover
                const pos = getPos(e);
                const dEye = Math.sqrt((pos.x - eyeX) ** 2 + (pos.y - eyeY) ** 2);
                if (dEye < 28) { canvas.style.cursor = 'move'; return; }
                const coinCY = tableY - coinThickness / 2;
                if (Math.abs(pos.x - coinX) < coinHalfW + 15 && Math.abs(pos.y - coinCY) < 25) {
                    canvas.style.cursor = 'ew-resize'; return;
                }
                const top = getMirrorTop();
                const dTop = Math.sqrt((pos.x - top.x) ** 2 + (pos.y - top.y) ** 2);
                const dSeg = distToSegment(pos.x, pos.y, mirrorBaseX, mirrorBaseY, top.x, top.y);
                if (dTop < 35 || dSeg < 20) { canvas.style.cursor = 'grab'; return; }
                canvas.style.cursor = 'default';
                return;
            }

            const pos = getPos(e);

            if (dragTarget === 'eye') {
                canvas.style.cursor = 'move';
                eyeX = Math.max(30, Math.min(W - 30, pos.x));
                eyeY = Math.max(30, Math.min(tableY - 30, pos.y));
            } else if (dragTarget === 'coin') {
                canvas.style.cursor = 'ew-resize';
                coinX = Math.max(coinHalfW + 5, Math.min(W - coinHalfW - 5, pos.x));
            } else if (dragTarget === 'mirror') {
                canvas.style.cursor = 'grabbing';
                const dx = pos.x - mirrorBaseX;
                const dy = pos.y - mirrorBaseY;
                let angle = Math.atan2(dx, -dy);
                mirrorAngle = Math.max(-maxTilt, Math.min(maxTilt, angle));
            }
            draw();
        }

        function endDrag() {
            dragTarget = null;
            canvas.style.cursor = 'default';
        }

        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', moveDrag);
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('mouseleave', endDrag);

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrag(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); moveDrag(e); }, { passive: false });
        canvas.addEventListener('touchend', endDrag);

        // Checkboxes
        document.getElementById('cbRays').addEventListener('change', (e) => { showRays = e.target.checked; draw(); });
        document.getElementById('cbImage').addEventListener('change', (e) => { showImage = e.target.checked; draw(); });
        document.getElementById('cbProjections').addEventListener('change', (e) => { showProjections = e.target.checked; draw(); });

        draw();
    </script>
</body>
</html>
