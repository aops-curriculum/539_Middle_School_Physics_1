<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corner Reflector – Second Reflection Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 16px 0;
        }
        canvas {
            display: block;
            border: 1px solid #333;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="500"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = 600, H = 500;

        // ── Corner reflector ──
        const vx = 280, vy = 230;
        const mirrorLen = 165;
        const md = mirrorLen / Math.SQRT2;

        const leftEnd  = { x: vx - md, y: vy + md };   // RED mirror
        const rightEnd = { x: vx + md, y: vy + md };    // BLACK mirror

        // Left mirror line: x + y = k
        const k = vx + vy;                               // 510

        // Right mirror line: x - y = c
        const c = vx - vy;                               // 50

        // Dashed extension of left mirror past vertex
        const extLen = 180;
        const extD = extLen / Math.SQRT2;
        const extEnd = { x: vx + extD, y: vy - extD };

        // ── Arrow shape constants ──
        const AL = 50;
        const BH = 16;
        const HH = 28;
        const HS = 15;

        // ── Object arrow ──
        const obj = { x: vx, y: 400, angle: 0, flipped: false };

        // ── First reflection (over right mirror) ──
        const img1 = {
            x: obj.y + c,              // 450
            y: obj.x - c,              // 230
            angle: Math.PI / 2,
            flipped: true
        };

        // ── Second reflection (over left mirror) ──
        const img2 = {
            x: k - img1.y,             // 280
            y: k - img1.x,             // 60
            angle: Math.PI,
            flipped: false
        };

        // ── 7 edge vertices of arrow in local coords ──
        const samplePoints = [
            { x: -AL, y: -BH },
            { x: -AL, y:  BH },
            { x:  HS, y: -BH },
            { x:  HS, y:  BH },
            { x:  HS, y: -HH },
            { x:  HS, y:  HH },
            { x:  AL, y:   0 },
        ];

        // Transform local point by arrow state
        function transformPoint(lx, ly, arrow) {
            let px = lx, py = ly;
            if (arrow.flipped) py = -py;
            const cos = Math.cos(arrow.angle);
            const sin = Math.sin(arrow.angle);
            return {
                x: arrow.x + px * cos - py * sin,
                y: arrow.y + px * sin + py * cos
            };
        }

        // Reflect point across the left mirror (line x + y = k)
        function reflectAcrossLeftMirror(px, py) {
            return { x: k - py, y: k - px };
        }

        // Find intersection of segment (p1→p2) with line x + y = k
        function segmentMirrorIntersection(p1, p2) {
            const d1 = p1.x + p1.y - k;
            const d2 = p2.x + p2.y - k;
            if (Math.abs(d1 - d2) < 1e-9) return null;
            const t = d1 / (d1 - d2);
            if (t < -0.01 || t > 1.01) return null;
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
            };
        }

        // ────────────────── drawing ──────────────────

        function drawArrow(x, y, angle, flipped, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.rotate(angle);
            if (flipped) ctx.scale(1, -1);

            // Top half (blue)
            ctx.beginPath();
            ctx.moveTo(-AL, 0);
            ctx.lineTo(-AL, -BH);
            ctx.lineTo(HS, -BH);
            ctx.lineTo(HS, -HH);
            ctx.lineTo(AL, 0);
            ctx.closePath();
            ctx.fillStyle = '#4488ff';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Bottom half (red)
            ctx.beginPath();
            ctx.moveTo(-AL, 0);
            ctx.lineTo(-AL, BH);
            ctx.lineTo(HS, BH);
            ctx.lineTo(HS, HH);
            ctx.lineTo(AL, 0);
            ctx.closePath();
            ctx.fillStyle = '#ee3333';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Centre divider
            ctx.beginPath();
            ctx.moveTo(-AL, 0);
            ctx.lineTo(AL, 0);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, W, H);

            // ── Corner reflector ──
            ctx.save();
            ctx.lineCap = 'round';

            // Left (RED) mirror
            ctx.beginPath();
            ctx.moveTo(vx, vy);
            ctx.lineTo(leftEnd.x, leftEnd.y);
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 5;
            ctx.stroke();

            // Dashed extension of left mirror past vertex
            ctx.beginPath();
            ctx.moveTo(vx, vy);
            ctx.lineTo(extEnd.x, extEnd.y);
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 6]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Right (BLACK) mirror
            ctx.beginPath();
            ctx.moveTo(vx, vy);
            ctx.lineTo(rightEnd.x, rightEnd.y);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 5;
            ctx.stroke();

            // Right-angle square at vertex
            const sq = 12;
            const u1x = (leftEnd.x - vx) / mirrorLen * Math.SQRT2;
            const u1y = (leftEnd.y - vy) / mirrorLen * Math.SQRT2;
            const u2x = (rightEnd.x - vx) / mirrorLen * Math.SQRT2;
            const u2y = (rightEnd.y - vy) / mirrorLen * Math.SQRT2;
            ctx.beginPath();
            ctx.moveTo(vx + u1x * sq, vy + u1y * sq);
            ctx.lineTo(vx + u1x * sq + u2x * sq, vy + u1y * sq + u2y * sq);
            ctx.lineTo(vx + u2x * sq, vy + u2y * sq);
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'butt';
            ctx.stroke();

            ctx.restore();

            // Vertex dot
            ctx.beginPath();
            ctx.arc(vx, vy, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.fill();

            // ── Object arrow ──
            drawArrow(obj.x, obj.y, obj.angle, obj.flipped, 1.0);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('object', obj.x, obj.y + HH + 10);

            // ── First reflection ──
            drawArrow(img1.x, img1.y, img1.angle, img1.flipped, 0.55);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('image in right mirror', img1.x, img1.y + AL + 10);

            // ── Second reflection ──
            drawArrow(img2.x, img2.y, img2.angle, img2.flipped, 0.55);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#999';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('image in left mirror', img2.x, img2.y + HH + 10);

            // ── Ray lines from first reflection to left mirror to second reflection ──
            const colors = [
                '#e67e22', '#2ecc71', '#9b59b6', '#1abc9c',
                '#e74c3c', '#3498db', '#f39c12'
            ];

            for (let i = 0; i < samplePoints.length; i++) {
                const lp = samplePoints[i];
                const src = transformPoint(lp.x, lp.y, img1);
                const dst = reflectAcrossLeftMirror(src.x, src.y);
                const hit = segmentMirrorIntersection(src, dst);

                const color = colors[i % colors.length];

                if (hit) {
                    // Solid line: first reflection point → mirror
                    ctx.beginPath();
                    ctx.moveTo(src.x, src.y);
                    ctx.lineTo(hit.x, hit.y);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([]);
                    ctx.stroke();

                    // Dotted line: mirror → second reflection point
                    ctx.beginPath();
                    ctx.moveTo(hit.x, hit.y);
                    ctx.lineTo(dst.x, dst.y);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Small dot at mirror hit
                    ctx.beginPath();
                    ctx.arc(hit.x, hit.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                }

                // Small dot on source point
                ctx.beginPath();
                ctx.arc(src.x, src.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Small dot on image point
                ctx.beginPath();
                ctx.arc(dst.x, dst.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        draw();
    </script>
</body>
</html>
