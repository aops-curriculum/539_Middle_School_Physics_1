<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loaded String Simulation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #fff;
      overflow: hidden;
    }
    main {
      width: 600px;
      height: 600px;
      position: relative;
    }
    .controls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 14px;
      color: #333;
      user-select: none;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
    .controls input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <main id="canvas-container">
    <div class="controls">
      <label>
        <input type="checkbox" id="showGraph"> Show position graph
      </label>
    </div>
  </main>
  <script>
    // ===========================================
    // LOADED STRING SIMULATION
    // Normal Mode Decomposition Approach
    // ===========================================
    
    // --- Physical Parameters ---
    const NUM_LOADS = 29;           // Number of point masses (odd for exact center)
    const STRING_TENSION = 1.0;     // Normalized tension
    const DAMPING = 0.998;          // Per-frame amplitude decay (higher modes decay faster)
    
    // --- Display Parameters ---
    const CANVAS_SIZE = 600;
    const STRING_Y = 180;                     // Vertical center of string at rest (moved up for graph)
    const STRING_LEFT = 50;                   // Left fixed point x-coordinate
    const STRING_RIGHT = CANVAS_SIZE - 50;   // Right fixed point x-coordinate
    const STRING_LENGTH = STRING_RIGHT - STRING_LEFT;
    const MAX_AMPLITUDE = 100;               // Maximum visual displacement in pixels
    
    // --- Graph Parameters ---
    const GRAPH_LEFT = 80;
    const GRAPH_RIGHT = CANVAS_SIZE - 40;
    const GRAPH_TOP = 340;
    const GRAPH_BOTTOM = 560;
    const GRAPH_WIDTH = GRAPH_RIGHT - GRAPH_LEFT;
    const GRAPH_HEIGHT = GRAPH_BOTTOM - GRAPH_TOP;
    const MAX_HISTORY = 900;                 // Number of data points to store
    
    // --- State Variables ---
    let massPositions = [];         // Current y-displacement of each mass (in pixels)
    let modeAmplitudes = [];        // Amplitude of each normal mode
    let modePhases = [];            // Phase of each normal mode (all start at 0 for pluck)
    let modeFrequencies = [];       // Angular frequency of each mode
    
    let isPlucking = false;         // Is mouse currently dragging?
    let pluckIndex = -1;            // Which mass is being plucked (nearest to mouse)
    let isVibrating = false;        // Is string currently vibrating?
    let time = 0;                   // Simulation time
    
    // --- Graph State ---
    let graphMassIndex = -1;        // Which mass to graph (set when pluck is released)
    let displacementHistory = [];   // Array of {time, displacement} objects
    let showGraphCheckbox;          // Reference to checkbox element
    
    // --- Precomputed Mode Shapes ---
    // modeShapes[k][j] = sin(k*pi*j/(n+1)) for mode k at mass j
    let modeShapes = [];
    
    function setup() {
      let canvas = createCanvas(CANVAS_SIZE, CANVAS_SIZE);
      canvas.parent('canvas-container');
      
      // Get checkbox reference
      showGraphCheckbox = document.getElementById('showGraph');
      
      // Initialize arrays
      for (let j = 0; j < NUM_LOADS; j++) {
        massPositions[j] = 0;
      }
      
      // Precompute mode shapes and frequencies
      // Mode indices go from 1 to NUM_LOADS (physics convention)
      // Array indices go from 0 to NUM_LOADS-1
      for (let k = 1; k <= NUM_LOADS; k++) {
        modeShapes[k] = [];
        for (let j = 1; j <= NUM_LOADS; j++) {
          // Mode shape: sin(k * pi * j / (n+1))
          modeShapes[k][j] = sin((k * PI * j) / (NUM_LOADS + 1));
        }
        
        // Mode frequency for loaded string (exhibits dispersion)
        // omega_k = 2 * omega_0 * sin(k * pi / (2*(n+1)))
        // We normalize omega_0 = 1 for simplicity
        modeFrequencies[k] = 2 * sin((k * PI) / (2 * (NUM_LOADS + 1)));
        
        // Initialize amplitudes and phases
        modeAmplitudes[k] = 0;
        modePhases[k] = 0;
      }
      
      // Frame rate for smooth animation
      frameRate(60);
    }
    
    function draw() {
      background(255);
      
      // Update physics
      if (isVibrating && !isPlucking) {
        updateVibration();
      }
      
      // Draw the string
      drawString();
      
      // Draw graph if enabled
      if (showGraphCheckbox && showGraphCheckbox.checked) {
        drawGraph();
      }
    }
    
    // --- Physics Update ---
    function updateVibration() {
      // Time step (scaled for visual speed - adjust to taste)
      const dt = 0.44;
      time += dt;
      
      // Reconstruct string position from modes
      for (let j = 1; j <= NUM_LOADS; j++) {
        let y = 0;
        for (let k = 1; k <= NUM_LOADS; k++) {
          // y_j(t) = sum over k of: A_k * cos(omega_k * t) * sin(k*pi*j/(n+1))
          y += modeAmplitudes[k] * cos(modeFrequencies[k] * time) * modeShapes[k][j];
        }
        massPositions[j - 1] = y;
      }
      
      // Record displacement for graph
      if (graphMassIndex >= 0 && showGraphCheckbox && showGraphCheckbox.checked) {
        displacementHistory.push({
          time: time,
          displacement: massPositions[graphMassIndex]
        });
        
        // Limit history length
        if (displacementHistory.length > MAX_HISTORY) {
          displacementHistory.shift();
        }
      }
      
      // Apply damping to mode amplitudes
      // Higher modes decay faster (realistic for strings)
      for (let k = 1; k <= NUM_LOADS; k++) {
        // Damping increases with mode number
        let dampingFactor = pow(DAMPING, 1 + k * 0.1);
        modeAmplitudes[k] *= dampingFactor;
      }
      
      // Check if vibration has effectively stopped
      let totalEnergy = 0;
      for (let k = 1; k <= NUM_LOADS; k++) {
        totalEnergy += modeAmplitudes[k] * modeAmplitudes[k];
      }
      if (totalEnergy < 0.0001) {
        isVibrating = false;
        time = 0;
      }
    }
    
    // --- Decompose Initial Shape into Normal Modes ---
    function computeModeAmplitudes() {
      // Discrete Sine Transform
      // A_k = (2/(n+1)) * sum over j of: y_j * sin(k*pi*j/(n+1))
      for (let k = 1; k <= NUM_LOADS; k++) {
        let amplitude = 0;
        for (let j = 1; j <= NUM_LOADS; j++) {
          amplitude += massPositions[j - 1] * modeShapes[k][j];
        }
        amplitude *= 2 / (NUM_LOADS + 1);
        modeAmplitudes[k] = amplitude;
        modePhases[k] = 0;  // Starting from rest means all phases are 0
      }
    }
    
    // --- Drawing Functions ---
    function drawString() {
      // Draw dashed midpoint line
      stroke(180);
      strokeWeight(1);
      drawingContext.setLineDash([6, 4]);
      let midX = (STRING_LEFT + STRING_RIGHT) / 2;
      line(midX, STRING_Y - MAX_AMPLITUDE - 20, midX, STRING_Y + MAX_AMPLITUDE + 20);
      drawingContext.setLineDash([]);  // Reset to solid
      
      // Draw the string
      stroke(0);
      strokeWeight(2);
      
      // Get x-positions of each mass
      let massX = [];
      for (let j = 0; j < NUM_LOADS; j++) {
        // Masses are evenly spaced
        massX[j] = STRING_LEFT + ((j + 1) * STRING_LENGTH) / (NUM_LOADS + 1);
      }
      
      // Draw string segments
      // From left fixed point to first mass
      line(STRING_LEFT, STRING_Y, massX[0], STRING_Y - massPositions[0]);
      
      // Between masses
      for (let j = 0; j < NUM_LOADS - 1; j++) {
        line(
          massX[j], STRING_Y - massPositions[j],
          massX[j + 1], STRING_Y - massPositions[j + 1]
        );
      }
      
      // From last mass to right fixed point
      line(massX[NUM_LOADS - 1], STRING_Y - massPositions[NUM_LOADS - 1], STRING_RIGHT, STRING_Y);
      
      // Draw fixed endpoints
      fill(80);
      noStroke();
      circle(STRING_LEFT, STRING_Y, 12);
      circle(STRING_RIGHT, STRING_Y, 12);
      
      // Draw marker on tracked mass if graphing
      if (showGraphCheckbox && showGraphCheckbox.checked) {
        if (isPlucking) {
          // During plucking: follow mouse position along the string
          let mx = constrain(mouseX, STRING_LEFT, STRING_RIGHT);
          let currentIndex = getClosestMassIndex(mx);
          let markerX = STRING_LEFT + ((currentIndex + 1) * STRING_LENGTH) / (NUM_LOADS + 1);
          let markerY = STRING_Y - massPositions[currentIndex];
          fill(0, 120, 200);
          noStroke();
          circle(markerX, markerY, 10);
        } else if (graphMassIndex >= 0) {
          // After release: show on tracked mass
          let markerX = STRING_LEFT + ((graphMassIndex + 1) * STRING_LENGTH) / (NUM_LOADS + 1);
          let markerY = STRING_Y - massPositions[graphMassIndex];
          fill(0, 120, 200);
          noStroke();
          circle(markerX, markerY, 10);
        }
      }
    }
    
    // --- Graph Drawing ---
    function drawGraph() {
      // Draw graph background
      fill(250);
      stroke(200);
      strokeWeight(1);
      rect(GRAPH_LEFT, GRAPH_TOP, GRAPH_WIDTH, GRAPH_HEIGHT);
      
      // Draw axes
      stroke(100);
      strokeWeight(1);
      
      // Y-axis (displacement)
      line(GRAPH_LEFT, GRAPH_TOP, GRAPH_LEFT, GRAPH_BOTTOM);
      
      // X-axis (time) - centered vertically
      let zeroY = GRAPH_TOP + GRAPH_HEIGHT / 2;
      line(GRAPH_LEFT, zeroY, GRAPH_RIGHT, zeroY);
      
      // Draw zero line dashed
      stroke(180);
      drawingContext.setLineDash([4, 4]);
      line(GRAPH_LEFT, zeroY, GRAPH_RIGHT, zeroY);
      drawingContext.setLineDash([]);
      
      // Axis labels
      fill(80);
      noStroke();
      textSize(12);
      textAlign(CENTER, CENTER);
      
      // "time" label
      text("time", GRAPH_LEFT + GRAPH_WIDTH / 2, GRAPH_BOTTOM + 18);
      
      // "displacement" label (rotated)
      push();
      translate(GRAPH_LEFT - 25, GRAPH_TOP + GRAPH_HEIGHT / 2);
      rotate(-HALF_PI);
      text("position", 0, 0);
      pop();
      
      // Draw the displacement curve
      if (displacementHistory.length > 1) {
        stroke(0, 120, 200);
        strokeWeight(2);
        noFill();
        
        beginShape();
        for (let i = 0; i < displacementHistory.length; i++) {
          // Map time to x position (scrolling view)
          let x = map(i, 0, MAX_HISTORY - 1, GRAPH_LEFT, GRAPH_RIGHT);
          
          // Map displacement to y position
          // Displacement is in pixels, scale to fit graph
          let y = map(displacementHistory[i].displacement, -MAX_AMPLITUDE, MAX_AMPLITUDE, GRAPH_BOTTOM, GRAPH_TOP);
          
          vertex(x, y);
        }
        endShape();
      }
      
      // Draw +/- labels on y-axis
      fill(120);
      textSize(10);
      textAlign(RIGHT, CENTER);
      text("+", GRAPH_LEFT - 5, GRAPH_TOP + 15);
      text("âˆ’", GRAPH_LEFT - 5, GRAPH_BOTTOM - 15);
    }
    
    // --- Mouse Interaction ---
    function mousePressed() {
      // Check if mouse is near the string (within interaction zone)
      if (mouseX > STRING_LEFT && mouseX < STRING_RIGHT) {
        if (abs(mouseY - STRING_Y) < MAX_AMPLITUDE + 50) {
          isPlucking = true;
          isVibrating = false;
          time = 0;
          
          // Find which mass is closest to mouse x-position
          pluckIndex = getClosestMassIndex(mouseX);
          
          // Update pluck shape
          updatePluckShape(mouseX, mouseY);
        }
      }
    }
    
    function mouseDragged() {
      if (isPlucking) {
        updatePluckShape(mouseX, mouseY);
      }
    }
    
    function mouseReleased() {
      if (isPlucking) {
        isPlucking = false;
        
        // Set the mass to graph based on release position (peak of pluck)
        graphMassIndex = getClosestMassIndex(mouseX);
        
        // Clear previous history
        displacementHistory = [];
        
        // Compute mode amplitudes from current shape
        computeModeAmplitudes();
        
        // Start vibrating
        isVibrating = true;
        time = 0;
      }
    }
    
    // --- Helper Functions ---
    function getClosestMassIndex(mx) {
      let closestDist = Infinity;
      let closestIndex = 0;
      
      for (let j = 0; j < NUM_LOADS; j++) {
        let massX = STRING_LEFT + ((j + 1) * STRING_LENGTH) / (NUM_LOADS + 1);
        let dist = abs(mx - massX);
        if (dist < closestDist) {
          closestDist = dist;
          closestIndex = j;
        }
      }
      return closestIndex;
    }
    
    function updatePluckShape(mx, my) {
      // Clamp mouse x to string bounds
      mx = constrain(mx, STRING_LEFT, STRING_RIGHT);
      
      // Calculate displacement (positive = up in screen coords, so we negate)
      let displacement = STRING_Y - my;
      displacement = constrain(displacement, -MAX_AMPLITUDE, MAX_AMPLITUDE);
      
      // Find the fractional position along the string (0 to 1)
      let pluckFraction = (mx - STRING_LEFT) / STRING_LENGTH;
      
      // Create triangular pluck shape
      // String forms two straight lines: left endpoint to pluck point to right endpoint
      for (let j = 0; j < NUM_LOADS; j++) {
        let massFraction = (j + 1) / (NUM_LOADS + 1);
        
        if (massFraction <= pluckFraction) {
          // Left side of pluck: linear interpolation from 0 to displacement
          massPositions[j] = displacement * (massFraction / pluckFraction);
        } else {
          // Right side of pluck: linear interpolation from displacement to 0
          massPositions[j] = displacement * ((1 - massFraction) / (1 - pluckFraction));
        }
      }
    }
  </script>
</body>
</html>
